# Dogfooding

In order for Drupal to be able to sustain both a decoupled front-end and an in-Drupal front-end, the way data gets sent and used by the presentation layer needs to be changed. In Drupal today, we have a tendency to conflate our data and our controllers which makes it an absolute mess for front-end developers to reliably get the output they'd like without at least intermediate PHP skills and a full PHP debugger. While this doesn't sound unreasonable to the back-end development community who already have these skills and tools, it's a large barrier to entry for those coming from any other front-end communities where their only required skills are HTML, CSS, JavaScript, and being able to read REST API documentation. In order to both attract new front-end developers to Drupal and enable Drupal to power the webapps of the future, we need to both [simplify and ease](https://austin2014.drupal.org/session/stomp-complexity) working with our data models, aligning the interaction model for each.

## RESTful Data Model

The first step towards creating a system where a Drupal generated front-end and an API driven front-end is to make both of them driven by an identical, presentation independent data model. Our current data model is messy and less structured than ideal, from render arrays to magically passed around variables (better known as the hook system) to infinitely recursive structures, it's almost a miracle that front-end developers can produce *anything* with Drupal. Sometimes the template we want to use is in one place, sometimes it's in another. There are incorporeal additions to our data structures that manifest within unknown parts of the stack and more often than not are tied directly to HTML presentation. The future of Drupal depends on stopping this practice.

Instead, our data models should adhere to the following guidelines:

* The only data that should be present in the data model should be raw data ready for filtering and the presentation layer.
* The data should be presentation (and thus context) independent. Context should be controlled by controllers
* Data should be stored in `key:value` pairs, not large arrays.
* Data models should contain no recursive structures
* The data model should follow the principles and constraints of [REST](http://en.wikipedia.org/wiki/Representational_state_transfer), allowing both headed and headless Drupal to absolutely share the same model without needing special case either.
* Alters should be exchanged for full replacements. To [quote Sam Boyer](https://twitter.com/sdboyer/status/475733416785510400), "You only get one good alter. After [the] first alter, [the] state is unknowable." This leads to a great deal of the headache involved in actually debugging and using the data model.

## Unmushed Controllers

Drupal right now has a tendency to mush controllers and models together into a hybrid much that's hard to deal with. It often leads to annoying and hard to debug instances where HTML of some kinds is being directly into a page without a proper separation of concerns. In order to resolve this, and to enforce the best practices of separation of presentation and content in modules that's needed for a headless state, anything that gets printed to a page is required to have a controller that is separate from the data model. This controller's sole purpose is to decide what data is available, and what view is being used. It itself doesn't hold content, isn't in charge of manipulating content, only determining what content is available to the view of the content, and how to update the model's state (*i.e.* form entry, AJAX requests, etcâ€¦).

In Drupal, the most logical concept to become a controller is the `block`. Instead of having view modes for entities and blocks as content and some blocks that aren't content but everything winds up getting displayed as blocks anyway, simply make the Block the single place to store all interactions between a model and a view. Then, larger blocks can be made up of smaller blocks with any content available in that block, without jumping through hoops to get it there.

Practically speaking, this would be that Views (and other like tools), instead of being a full MVC stack on their own, would exist to solely generate different data streams (that would work equally well for both headed and headless Drupal), and a block would be created separately to display that data stream, potentially in a variety of different ways.

## The Views, the Assets, and the Princess

In Drupal 8, we have already taken a great step forward to ensuring the view system is both simple and easy to work with by moving to Twig, but that is only half of what we need to do to have a fully functional, front-end developer friendly view system. Each view, in addition to providing the HTML for the view, should be able to declare dependent assets (JavaScript, CSS) that it needs to work properly. Assets should come in two forms, either as libraries that can only be attached if a view is dependent on them, or as raw assets tied directly to a view. This is an important step in moving away from the situation we currently have in which assets, especially JavaScript, is injected directly into a page and therefore uncontrollable from a front-end developer's perspective. By tying assets to a view, it also makes it easy to swap out whole pieces of functionality with custom functionality instead of needing to dig through layers upon layers of crap. Finally, by not allowing direct injection of assets, it will encourage and reinforce the best practice separation of configuration and presentation in modules and ensure that module developers don't rely upon magic for their functionality to work.

An added advantage to headed Drupal of having assets tied to views and doing away with alters (especially for views and assets) is that the system can know what assets, and what each asset depends on, are required for a page to load *before* it loads. This will allow for smarter asset bundles and better headed Drupal performance. If coupled with a page management tool (*page* management tool for managing what goes on a page, not *layout* management tool for managing how content gets laid out on a page), headed Drupal performance could greatly improve through technologies like ESI and standard, easy to work with content lazyloading. It would also benefit headless Drupal by providing a single API endpoint for all content at a route, allowing a single HTTP request instead of multiple, small HTTP requests to build a page, giving site builders a simple, easy, and standard way of controlling content on either a headed or headless Drupal instance.
